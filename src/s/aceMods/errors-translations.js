/* eslint-disable no-unused-vars */
export default {
  AssertionError: [
    {
      reg: /^(.*)(?: on line (\d+))?$/i,
      en: (line) => `Error caused by an assert statement`,
      enWhen: `This error occurs when the check in an assert statement fails.`,
      enFix: `The assert statement is used like this: assert boolean_expression, optional_expression. If boolean_expression returns False, an AssertionError is raised with the optional_expression as the message (if provided).`,
      errEx: `assert 0,0`,
    },
    {
      reg: /^(?: on line (\d+))?$/i,
      en: (line) => `Error caused by an assert statement`,
      enWhen: `This error occurs when the check in an assert statement fails.`,
      enFix: `The assert statement is used like this: assert boolean_expression, optional_expression. If boolean_expression returns False, an AssertionError is raised with the optional_expression as the message (if provided).`,
      errEx: `assert False`,
    },
  ],
  AttributeError: [
    {
      reg: /^(.*?) object has no attribute (.*?)(?: on line (\d+))?$/i,
      en: (obj, attr, line) => `Object of type '${obj}' has no attribute '${attr}'`,
      enWhen: `This error occurs when you try to use an attribute or method that the object does not have. For example: "a".leng()`,
      enFix: `Check the attribute/method name. You might have a typo. Sometimes, you need to use a function instead of a method (e.g., "a".len() should be len("a")).`,
      errEx: `{}.a()`,
    },
  ],
  Error: [
    {
      reg: /^Assertion failure\: (.*)$/i,
      en: (line) => ``,
      enWhen: ``,
      enFix: ``,
      errEx: `class A: pass\ndel A.__dict__`,
    },
  ],
  Exception: [
    {
      reg: /^(?: on line \d+)?$/i,
      en: (line) => ``,
      enWhen: ``,
      enFix: ``,
      errEx: `raise Exception from 1`,
    },
  ],
  ExternalError: [
    {
      reg: /^.*haven't implemented non-read opens(?: on line (\d+))?$/i,
      en: (line) => `Writing to files is not supported`,
      enWhen: `This error occurs when you try to write to a file.`,
      enFix: `Do not use file writing in the web version of the interpreter.`,
      errEx: `open("/a", 'w')`,
    },
    {
      reg: /^(.*) is not a constructor(?: on line (\d+))?$/i,
      en: (str, line) => `'${str}' is not a constructor`,
      enWhen: ``,
      enFix: ``,
      errEx: `object.__new__(1)`,
    },
    {
      reg: /^TypeError\: Cannot read property \'(.*)\' of undefined(?: on line \d+)?$/i,
      en: (line) => `The type() function expects exactly 1 or 3 arguments`,
      enWhen: `This error occurs when you provide the wrong number of arguments.`,
      enFix: `Check the number of arguments: it should be 1 or 3. For example, type(1).`,
      errEx: `type(0,0)`,
    },
    {
      reg: /^RangeError: Maximum call stack size exceeded on line undefined$/i,
      en: (line) => ``,
      enWhen: ``,
      enFix: ``,
      errEx: `a = lambda x: a(x); a(a)`,
    },
    {
      reg: /^TypeError\: (.*)\(\w+\, \w+\)\: (.*) must be callable(?: on line \d+)?$/i,
      en: (arg, str, line) => `The first argument '${arg}' of the function '${str}' must be callable`,
      enWhen: `This error occurs when two arguments are passed, and the first one is not callable (i.e., it is not a function).`,
      enFix: ``,
      errEx: `iter(1,2)`,
    },
    {
      reg: /^\[.*\](?: on line \d+)?$/i,
      en: (line) => ``,
      enWhen: ``,
      enFix: ``,
      errEx: `raise 1`,
    },
    {
      reg: /^TypeError\: Cannot read property \'(.*)\' of (.*)(?: on line \d+)?$/i,
      en: (str, obj, line) => `Type error: cannot read property '${str}' of object '${obj}'`,
      enWhen: ``,
      enFix: ``,
      errEx: `"%*d"%""`,
    },
  ],
  IOError: [
    {
      reg: /^\[Errno 2\] No such file or directory: \'(.*)\'(?: on line \d+)?$/i,
      en: (file, line) => `File '${file}' does not exist`,
      enWhen: `In the web version of the interpreter, you can only read files that are explicitly specified in the problem description.`,
      enFix: `Make sure the filename you are trying to read matches the one in the problem description.`,
      errEx: `open('.')`,
    },
  ],
  ImportError: [
    {
      reg: /^No module named (\w+)(?: on line (\d+).?)?$/i,
      en: (mod, line) => `Module named '${mod}' does not exist.`,
      enWhen: `This error occurs when you try to import a module that does not exist.`,
      enFix: `Import available modules like: drawzero, time, etc.`,
      errEx: `import z`,
    },
  ],
  IndexError: [
    {
      reg: /^list assignment index out of range(?: on line (\d+))?$/i,
      en: (line) => `The index for assignment is out of range`,
      enWhen: `This error occurs when you try to assign a value to an element that does not exist.`,
      enFix: `Make sure the index is correct and within the allowed range. For example, you can assign to an existing index: [1, 2][0] = 0.`,
      errEx: `[][0]=0`,
    },
    {
      reg: /^list index out of range(?: on line (\d+).?)?$/i,
      en: (line) => `List index is greater than or equal to its length.`,
      enWhen: `This error occurs when you try to access a list element using an index that is greater than or equal to the list length.`,
      enFix: `Use a smaller index. Remember that indexing starts from 0.`,
      errEx: `[0][1]`,
    },
    {
      reg: /^pop index out of range(?: on line (\d+).?)?$/i,
      en: (line) => `Index for pop is out of the list's range`,
      enWhen: `This error occurs when you call pop() on an empty list, or pop(n) where n is greater than or equal to the list length.`,
      enFix: `Make sure the list is not empty or use a smaller index. Remember that indexing starts from 0.`,
      errEx: `[].pop()`,
    },
    {
      reg: /^string index out of range(?: on line (\d+).?)?$/i,
      en: (line) => `String index is out of range`,
      enWhen: `This error occurs when you request an element by an index that does not exist in the object.`,
      enFix: `Make sure the element you are looking for exists. For example, 'abc'[0] is valid.`,
      errEx: `""[1]`,
    },
    {
      reg: /^tuple index out of range(?: on line (\d+).?)?$/i,
      en: (line) => `Tuple index is out of range`,
      enWhen: `This error occurs when you request an element by an index that does not exist in the tuple.`,
      enFix: `Make sure the element you are looking for exists. For example, (1, 2, 3)[1] is valid.`,
      errEx: `(1,)[2]`,
    },
  ],
  KeyError: [
    {
      reg: /^(.*?)(?: on line (\d+))?$/i,
      en: (key, line) => `The key ${key} is not in the dictionary.`,
      enWhen: ``,
      enFix: `Make sure the key exists in the dictionary. You can check for it using "key in my_dict", or get a value with a default: my_dict.get(key, default_value).`,
      errEx: `{}[0]`,
    },
    {
      reg: /^pop from an empty set(?: on line (\d+))?$/i,
      en: (line) => `Error when popping from an empty set`,
      enWhen: ``,
      enFix: `Make sure the object you are calling pop() on is not empty.`,
      errEx: `set().pop()`,
    },
  ],
  NameError: [
    {
      reg: /^name '(.*?)' is not defined(?: on line (\d+))?$/i,
      en: (str, line) => `Variable '${str}' is not defined`,
      enWhen: `This error occurs when you use a variable that has not been defined yet.`,
      enFix: (str, line) => `Define this variable before using it, for example: ${str} = 10`,
      errEx: `__builtins__.__build_class__(1,2)`,
    },
  ],
  NegativePowerError: [
    {
      reg: /^cannot raise a negative number to a fractional power(?: on line \d+)?$/i,
      en: (line) => `Cannot raise a negative number to a fractional power`,
      enWhen: `This error occurs when you try to raise a negative number to a power like 0.5, for example: (-2)**0.5.`,
      enFix: `Either make the number positive or make the power an integer.`,
      errEx: `(-2)**0.5`,
    },
    {
      reg: /^cannot raise zero to a negative power(?: on line (\d+).?)?$/i,
      en: (line) => `Cannot raise 0 to a negative power`,
      enWhen: `This error occurs when you try to raise 0 to a negative power.`,
      enFix: `Either make the number non-zero or make the power positive.`,
      errEx: `0**-2`,
    },
    {
      reg: /^cannot raise zero to a negative power(?: on line (\d+).?)?$/i,
      en: (line) => `Cannot raise 0 to a negative power`,
      enWhen: `This error occurs when you try to raise 0 to a negative power.`,
      enFix: `Either make the number non-zero or make the power positive.`,
      errEx: `0**-2`,
    },
  ],
  NotImplementedError: [
    {
      reg: /^(.*?) is not yet implemented.*?(?:on line (\d+))?$/i,
      en: (cmd, line) => `The command '${cmd}' is not currently supported.`,
      enWhen: `This error occurs when you try to use commands that are not supported in our course.`,
      enFix: `Think of a way to solve the problem without using this command.`,
      errEx: `from __future__ import braces`,
    },
  ],
  OverflowError: [
    {
      reg: /^absolute value too large(?: on line (\d+))?$/i,
      en: (line) => `The absolute value of the number is too large`,
      enWhen: `The absolute value of the number exceeds 10^308 and does not fit into the float type.`,
      enFix: ``,
      errEx: `abs((1+1j)*10**308*1.3)`,
    },
    {
      reg: /^Numerical result out of range(?: on line (\d+))?$/i,
      en: (line) => `Numerical result is out of range`,
      enWhen: `This error occurs when the result of a calculation is too large to be represented.`,
      enFix: `Use smaller numbers or reduce the number of mathematical operations.`,
      errEx: `10.0 ** 10.0 ** 10.0`,
    },
  ],
  RuntimeError: [
    {
      reg: /^(.*) no arguments(?: on line (\d+))?$/i,
      en: (str, line) => `Missing arguments for function '${str}'`,
      enWhen: `This error occurs when a function does not receive any arguments.`,
      enFix: `Provide the required arguments to the function.`,
      errEx: `super()`,
    },
  ],
  StopIteration: [
    {
      reg: /^(?: on line (\d+))?$/i,
      en: (line) => `The iterator has no more items`,
      enWhen: ``,
      enFix: ``,
      errEx: `next(iter([]))`,
    },
  ],
  SyntaxError: [
    {
      reg: /^(.*) outside function$/i,
      en: (str, line) => `'${str}' outside of a function`,
      enWhen: (str, line) => `This error occurs when '${str}' is used outside of a function body.`,
      enFix: (str, line) => `Make sure the '${str}' statement is inside a function body. Check if the function exists and check your indentation.`,
      errEx: `return`,
    },
    {
      reg: /^(.*) outside loop$/i,
      en: (str, line) => `'${str}' outside of a loop`,
      enWhen: (str, line) => `This error occurs when '${str}' is used outside of a loop.`,
      enFix: (str, line) => `Make sure the '${str}' statement is inside a loop. Check if the loop exists and check your indentation.`,
      errEx: `break`,
    },
    {
      reg: /^(.*) outside loop$/i,
      en: (str, line) => `'${str}' outside of a loop`,
      enWhen: (str, line) => `This error occurs when '${str}' is used outside of a loop.`,
      enFix: (str, line) => `Make sure the '${str}' statement is inside a loop. Check if the loop exists and check your indentation.`,
      errEx: `continue`,
    },
    {
      reg: /^\'(.*)\' with argument inside generator at$/i,
      en: (str, line) => `'${str}' inside a generator`,
      enWhen: ``,
      enFix: `Use yield and return without an expression.`,
      errEx: `def f():\n    yield\n    return 1`,
    },
    {
      reg: /^annotated name (.*) can't be global(?: on line (\d+))?$/i,
      en: (str, line) => `Annotated variable '${str}' cannot be global`,
      enWhen: ``,
      enFix: `Check your code for correctness.`,
      errEx: `def f():\n    global a\n    a: int = 1`,
    },
    {
      reg: /^illegal target for annotation(?: on line \d+)?$/i,
      en: (line) => `Syntax error`,
      enWhen: `This error occurs if your code is not written correctly.`,
      enFix: `Check your parentheses and indentation, these are the most common mistakes.`,
      errEx: `f(): int`,
    },
    {
      reg: /^bad input(?: on line (\d+).?)?$/i,
      en: (line) => `Syntax error.`,
      enWhen: `This error occurs if your code is not written correctly.`,
      enFix: `Check your parentheses and indentation, these are the most common mistakes.`,
      errEx: `def a(): await a()`,
    },
    {
      reg: /^can\'t assign to (.*)(?: on line \d+)?$/i,
      en: (line) => `Syntax error`,
      enWhen: `This error occurs if your code is not written correctly.`,
      enFix: `Most likely, there is an invalid character in your code (for example, $).`,
      errEx: `() = 1`,
    },
    {
      reg: /^bad token.*(?:on line (\d+).?)?$/i,
      en: (line) => `Syntax error.`,
      enWhen: `This error occurs if your code is not written correctly.`,
      enFix: `Most likely, there is an invalid character in your code (for example, $ or a Cyrillic letter).`,
      errEx: `$`,
    },
    {
      reg: /^can\'t assign to (.*) expression(?: on line (\d+))?$/i,
      en: (str, line) => `Cannot assign to ${str}`,
      enWhen: ``,
      enFix: ``,
      errEx: `(yield)=1`,
    },
    {
      reg: /^can\'t assign to function call(?: on line (\d+))?$/i,
      en: (line) => `Cannot assign to a function call`,
      enWhen: `This error is caused by an incorrect function call.`,
      enFix: `Most likely, the code for calling this function is written incorrectly.`,
      errEx: `id() = 1`,
    },
    {
      reg: /^can\'t assign to literal(?: on line (\d+))?$/i,
      en: (line) => `Cannot assign to a literal`,
      enWhen: ``,
      enFix: `Make sure there is a variable on the left side of the assignment operator. For example, a = 1.`,
      errEx: `1=1`,
    },
    {
      reg: /^can\'t assign to operator(?: on line (\d+))?$/i,
      en: (line) => `Cannot assign to an operator`,
      enWhen: `This error occurs with an incorrect assignment or an invalid variable name.`,
      enFix: `Make sure there is a variable to the left of the "=" assignment operator. Also, make sure the variable name does not contain characters like *, +, -, /.`,
      errEx: `-1=1`,
    },
    {
      reg: /^can\'t assign to True, False or None(?: on line (\d+))?$/i,
      en: (line) => `Cannot assign a value to True, False, or None`,
      enWhen: ``,
      enFix: `Make sure there is a variable to the left of the "=" assignment operator. The words True, False, and None cannot be used as variable names.`,
      errEx: `True = False`,
    },
    {
      reg: /^can\'t delete function call(?: on line (\d+))?$/i,
      en: (line) => `Cannot delete a function call`,
      enWhen: ``,
      enFix: ``,
      errEx: `del id()`,
    },
    {
      reg: /^default (.*) must be last$/i,
      en: (str, line) => `The '${str}' block must be last`,
      enWhen: `This error occurs in a try...except block when a default except block (one without a specific exception type) is not the last one.`,
      enFix: `Make sure you have written the exception handling structure correctly. For example: \ntry:\n    pass\nexcept:\n    pass`,
      errEx: `try:\n    pass\nexcept:\n    pass\nexcept 1:\n    pass`,
    },
    {
      reg: /^duplicate argument \'(.*)\' in function definition on line (.*)$/i,
      en: (str, line) => `Duplicate argument '${str}' in function definition`,
      enWhen: `This error occurs when an argument is defined more than once in a function definition.`,
      enFix: `Make sure the arguments in the function are written correctly and are unique. For example, def q(a, b): pass.`,
      errEx: `def f(a,a): pass`,
    },
    {
      reg: /^EOF in multi-line string(?: on line (\d+))?$/i,
      en: (line) => `Error processing triple quotes`,
      enWhen: `This error occurs when quotes are used incorrectly. Perhaps a string started with triple quotes but was not closed.`,
      enFix: `Check that you are using quotes correctly. Common ways: 1) For a regular string: 'abc' or "abc". 2) For a multi-line string or docstring: """ This function works like this """`,
      errEx: `"""`,
    },
    {
      reg: /^Invalid or unexpected token$/i,
      en: (line) => `Syntax error`,
      enWhen: `This error occurs if there is an invalid character in the code.`,
      enFix: `Most likely, there is an invalid character in your code (for example, №).`,
      errEx: `№`,
    },
    {
      reg: /^invalid string \(.*\)(?: on line \d+)?$/i,
      en: (line) => `Syntax error`,
      enWhen: `This error occurs if there is an invalid character in the code.`,
      enFix: `Most likely, there is an invalid character in your code (for example, №).`,
      errEx: `f'{\}'`,
    },
    {
      reg: /^keyword argument repeated(?: on line (\d+))?$/i,
      en: (line) => `Syntax error: keyword argument repeated`,
      enWhen: `This error occurs when the same keyword argument is passed more than once.`,
      enFix: `Check the arguments you are passing. Remember that they should not be repeated. For example, f(a=1, b=2).`,
      errEx: `f(a=1,a=1)`,
    },
    {
      reg: /^name \'(.*)\' is assigned to before global declaration(?: on line \d+)?$/i,
      en: (str, line) => `Variable '${str}' is assigned a value before its global declaration`,
      enWhen: ``,
      enFix: `Make sure the global declaration for the variable comes before any assignments to it.`,
      errEx: `def f():\n    a = 1\n    global a`,
    },
    {
      reg: /^named arguments must follow bare \*(?: on line (\d+))?$/i,
      en: (line) => `Arguments must follow a bare *`,
      enWhen: ``,
      enFix: ``,
      errEx: `def f(*): pass`,
    },
    {
      reg: /^non-default argument follows default argument(?: on line (\d+))?$/i,
      en: (line) => `Non-default arguments must come before default arguments`,
      enWhen: ``,
      enFix: `Make sure that parameters with default values come after parameters without default values. For example, def w(a, c=4):, where "a" is a non-default parameter and "c" has a default value of 4.`,
      errEx: `def f(a=1, b): pass`,
    },
    {
      reg: /^trailing comma not allowed without surrounding parentheses(?: on line (\d+))?$/i,
      en: (line) => `A trailing comma is not allowed without surrounding parentheses`,
      enWhen: ``,
      enFix: `Make sure there are no extra commas in your code. Or, if a comma is necessary, use parentheses.`,
      errEx: `from a import b, c,`,
    },
    {
      reg: /^(.*) unpacking with stars is not supported at (.*)$/i,
      en: (str, line) => `Cannot unpack object of type '${str}' using *`,
      enWhen: ``,
      enFix: ``,
      errEx: `*a, *a = a`,
    },
    {
      reg: /^Unexpected token \'(.*)\'$/i,
      en: (str, line) => `Unexpected token '${str}'`,
      enWhen: `Perhaps there is a typo in the line.`,
      enFix: `Make sure there are no extra characters in your code.`,
      errEx: `a = *a`,
    },
  ],
  TimeLimitError: [
    {
      reg: /^Program exceeded run time limit.(?: on line (\d+).)?$/i,
      en: (line) => `The program is taking too long to run.`,
      enWhen: `This error often occurs because of infinite loops or very complex calculations.`,
      enFix: `Check the exit conditions of your loops and try to make your solution more efficient.`,
      errEx: `for i in range(10**6): i = i`,
    },
  ],
  TypeError: [
    {
      reg: /^(.*?) object is not iterable(?: on line (\d+).?)?$/i,
      en: (type, line) => `Object of type '${type}' is not iterable`,
      enWhen: `This error occurs when you try to loop over a number (like "for i in 5"), "unpack" a number (like "a, b = 5"), or iterate over another non-iterable type.`,
      enFix: `You can only iterate over lists, tuples, dictionaries, sets, or strings, not numbers.`,
      errEx: `class A():\n    pass\niter(A())`,
    },
    {
      reg: /^(.*)\(\) takes at least \d+ arguments \(\d+ given\)(?: on line \d+)?$/i,
      en: (func, num, given, line) => `Function ${func} takes at least ${num} argument(s), but ${given} were given`,
      enWhen: `This error occurs when not enough arguments are passed to a function. For example, int().`,
      enFix: `Add the missing arguments.`,
      errEx: `{}.fromkeys()`,
    },
    {
      reg: /^(.*) 3rd argument not allowed unless all arguments are integers(?: on line (\d+))?$/i,
      en: (str, line) => `The 3rd argument is not allowed if the first two arguments of ${str} are not integers or if the second argument is not positive`,
      enWhen: ``,
      enFix: (str, line) => `Make sure that integer arguments are passed to the ${str} function, and that the second argument is not negative.`,
      errEx: `pow(1., 0, 0)`,
    },
    {
      reg: /^(.*) arg must be None or str(?: on line (\d+))?$/i,
      en: (str, line) => `The argument for function ${str} must be an object of type str or None.`,
      enWhen: ``,
      enFix: `Make sure the arguments are written correctly.`,
      errEx: `"1x".lstrip(1)`,
    },
    {
      reg: /^(.*) argument 1 must be str, not int(?: on line (\d+))?$/i,
      en: (str, obj, obj2, line) => `The first argument for function ${str} must be an object of type ${obj}, not type ${obj2}`,
      enWhen: ``,
      enFix: (str, obj, obj2, line) => `Correct the arguments for the ${str} function.`,
      errEx: `type(123, (), {})`,
    },
    {
      reg: /^(.*) argument 2 must be tuple, not list(?: on line (\d+))?$/i,
      en: (str, obj, obj2, line) => `The second argument for function ${str} must be an object of type ${obj}, not type ${obj2}`,
      enWhen: ``,
      enFix: (str, obj, obj2, line) => `Correct the arguments for the ${str} function.`,
      errEx: `type("ClassName", [], {})`,
    },
    {
      reg: /^(.*) argument 3 must be dict, not NoneType(?: on line (\d+))?$/i,
      en: (str, obj, obj2, line) => `The third argument for function ${str} must be an object of type ${obj}, not type ${obj2}`,
      enWhen: ``,
      enFix: (str, obj, obj2, line) => `Correct the arguments for the ${str} function.`,
      errEx: `type("ClassName", (), None)`,
    },
    {
      reg: /^(.*)\(\) argument can\'t be converted to (.*)(?: on line (\d+))?$/i,
      en: (func, type, line) => `The argument for function ${func} cannot be converted to type ${type}`,
      enWhen: `This error occurs when trying to pass a non-integer object to the function.`,
      enFix: ``,
      errEx: `hex("abc")`,
    },
    {
      reg: /^(.*) argument must be a string or a number, not (.*?)(?: on line (\d+))?$/i,
      en: (str, type, line) => `The argument for function ${str} must be a string or a number, not ${type}.`,
      enWhen: (str, line) => `This error occurs when you try to convert an invalid object to a number using the ${str} function.`,
      enFix: `Make sure you are passing a string or a number to int() (e.g., int("1") or int(1.5)).`,
      errEx: `int(None)`,
    },
    {
      reg: /^(.*) argument must be a string or number(?: on line (\d+))?$/i,
      en: (str, line) => `The argument for the ${str} constructor must be a string or a number`,
      enWhen: ``,
      enFix: `Check the arguments being passed.`,
      errEx: `complex(None)`,
    },
    {
      reg: /^(.*) attribute name must be (.*)(?: on line (\d+))?$/i,
      en: (str, line) => `The 'name' attribute of the function must be an object of type ${str}`,
      enWhen: ``,
      enFix: ``,
      errEx: `hasattr(1,2)`,
    },
    {
      reg: /^(.*) can\'t convert non-string with explicit base(?: on line (\d+))?$/i,
      en: (str, line) => `The ${str} function cannot convert a non-string object with an explicit base`,
      enWhen: (str, line) => `This error occurs when you try to convert an invalid object to a number using the ${str} function.`,
      enFix: `Make sure you pass a string as the first argument and a number as the second argument to int(). For example, int("123", 10).`,
      errEx: `int(0,0)`,
    },
    {
      reg: /^(.*) can\'t sum strings \[use \'\'\.join\(seq\) instead\](?: on line (\d+))?$/i,
      en: (str, line) => `The ${str} function cannot sum strings (use ''.join(sequence) instead)`,
      enWhen: ``,
      enFix: `To concatenate strings, use the join() method. Use the sum() function for iterables containing numbers. For example, '.'.join(['1', '2']) or sum([1, 2]).`,
      errEx: `sum([],"")`,
    },
    {
      reg: /^(.*) does not support indexing(?: on line (\d+))?$/i,
      en: (str, line) => `Object of type '${str}' does not support indexing`,
      enWhen: (str, line) => `This error occurs when you try to access an element of type '${str}' by its index.`,
      enFix: `Make sure you only use indexing with objects that support it (like lists, strings, tuples).`,
      errEx: `1[1]`,
    },
    {
      reg: /^(.*) does not support item assignment(?: on line (\d+))?$/i,
      en: (str, line) => `Object of type '${str}' does not support item assignment`,
      enWhen: ``,
      enFix: (str, line) => `Make sure you are not trying to assign a value to an item of an immutable (unchangeable) type like '${str}'.`,
      errEx: `1[1]=1`,
    },
    {
      reg: /^(.*) expected a character, but string of length (\d+) found(?: on line (\d+))?$/i,
      en: (str, len, line) => `Function ${str} expected a character, but a string of length ${len} was found`,
      enWhen: ``,
      enFix: (str, len, line) => `Make sure the ${str} function receives a string containing only one character.`,
      errEx: `ord("ab")`,
    },
    {
      reg: /^(.*) got an unexpected keyword argument (.*)(?: on line (\d+).?)?$/i,
      en: (obj, parm, line) => `'${obj}' got an unexpected keyword argument '${parm}'.`,
      enWhen: `This error occurs when you pass a keyword argument that the function does not expect.`,
      enFix: `Check the parameter name and the function/method's available parameters.`,
      errEx: `int(z=1)`,
    },
    {
      reg: /^(.*) indices must be integers or None(?: on line (\d+))?$/i,
      en: (str, line) => `Indices for object '${str}' must be integers or None`,
      enWhen: ``,
      enFix: ``,
      errEx: `""[.2:.2]`,
    },
    {
      reg: /^(.*) indices must be integers, not float(?: on line (\d+))?$/i,
      en: (str, line) => `Indices for object '${str}' must be integers, not float`,
      enWhen: ``,
      enFix: ``,
      errEx: `""[1.2]`,
    },
    {
      reg: /^(.*) must be None or a string, not int(?: on line (\d+))?$/i,
      en: (str, line) => `The value for the '${str}' separator must be either None or a string, not an integer`,
      enWhen: ``,
      enFix: (str, line) => `Check the value passed to the '${str}' separator. For example, print(a, b, c, d, sep='+').`,
      errEx: `print(end=1)`,
    },
    {
      reg: /^(.*) must return (.*)(?: on line (\d+))?$/i,
      en: (meth, type, line) => `Method ${meth} must return an object of type ${type}`,
      enWhen: ``,
      enFix: ``,
      errEx: `class A:\n    def __dir__(self):\n        return 1\ndir(A())`,
    },
    {
      reg: /^(.*) object cannot be interpreted as an integer(?: on line (\d+))?$/i,
      en: (str, line) => `'${str}' object cannot be interpreted as an integer`,
      enWhen: `This error occurs when a NoneType object is used where an integer is expected.`,
      enFix: ``,
      errEx: `class A:\n    def __len__(self):\n        return None\nlen(A())`,
    },
    {
      reg: /^(.*) object does not support item deletion(?: on line (\d+))?$/i,
      en: (str, line) => `Object '${str}' does not support item deletion`,
      enWhen: ``,
      enFix: ``,
      errEx: `del {1,2,3}[1:2]`,
    },
    {
      reg: /^(.*) object is not a sequence(?: on line (\d+))?$/i,
      en: (str, line) => `Object of type '${str}' is not a sequence`,
      enWhen: `This error occurs when you try to pass an object that is not a sequence to a function that expects one.`,
      enFix: `Types of sequences include: list, tuple, range, string, array.`,
      errEx: `reversed(1)`,
    },
    {
      reg: /^(.*) object is not callable(?: on line (\d+))?$/i,
      en: (obj, line) => `Object '${obj}' is not callable`,
      enWhen: `This error occurs when you try to "call" an object that is not a function by using parentheses ().`,
      enFix: (obj, line) => `Make sure you don't have extra parentheses and that operations with objects of type '${obj}' are correct.`,
      errEx: `()()`,
    },
    {
      reg: /^(.*) object is not iterable(?: on line (\d+).?)?$/i,
      en: (line) => `Cannot iterate over an integer`,
      enWhen: `This error occurs when you try to loop over a number (like "for i in 5") or "unpack" a number (like "a, b = 5").`,
      enFix: `You can only iterate over lists, tuples, dictionaries, sets, or strings, not numbers.`,
      errEx: `a, b = 5`,
    },
    {
      reg: /^(.*) returned non-(.*) (.*)(?: on line (\d+))?$/i,
      en: (str, obj, type, line) => `Method ${str} returned an object of type ${obj} instead of ${type}`,
      enWhen: ``,
      enFix: ``,
      errEx: `class A:\n    def __index__(self):\n        return 1.5\n[][A()]`,
    },
    {
      reg: /^(.*) should return (.*)(?: on line (\d+))?$/i,
      en: (meth, type, line) => `Method ${meth} must return an object of type ${type}`,
      enWhen: ``,
      enFix: ``,
      errEx: `class A:\n    def __complex__(self):\n        return "1+2j"\ncomplex(A())`,
    },
    {
      reg: /^(.*) should return (.*), returned (.*)(?: on line (\d+))?$/i,
      en: (meth, type, obj, line) => `Method ${meth} should return an object of type ${type} instead of ${obj}`,
      enWhen: ``,
      enFix: ``,
      errEx: `class A:\n    def __bool__(self):\n        return "yes"\nnot A()`,
    },
    {
      reg: /^(.*) should return (.*), not (.*)(?: on line (\d+))?$/i,
      en: (meth, type, obj, line) => `Method ${meth} should return an object of type ${type} instead of ${obj}`,
      enWhen: ``,
      enFix: ``,
      errEx: `class A:\n    def __init__(self):\n        return {}\nA()`,
    },
    {
      reg: /^(.*)\(\) takes \d+ positional arguments but \d+ were given(?: on line (\d+))?$/i,
      en: (func, good, real, line) => `Function ${func} takes ${good} positional arguments, but ${real} were given.`,
      enWhen: `This error occurs when you pass too many arguments to a function.`,
      enFix: `Check the function/method parameters and how you are calling it.`,
      errEx: `int(1, 2, 3)`,
    },
    {
      reg: /^(.*)\(\) takes at most (\d+) arguments \((\d+) given\)(?: on line (\d+))?$/i,
      en: (func, good, real, line) => `Function ${func} takes at most ${good} arguments, but ${real} were given.`,
      enWhen: `This error occurs when you pass too many arguments to a function.`,
      enFix: `Check the function/method parameters and how you are calling it.`,
      errEx: `str(1, 2)`,
    },
    {
      reg: /^attribute name must be (.*)(?: on line (\d+))?$/i,
      en: (str, type, line) => `Attribute '${str}' must be an object of type ${type}`,
      enWhen: `This error occurs with incorrect passing of function arguments.`,
      enFix: (str, type, line) => `The ${str} function takes 3 arguments: object - the object whose attribute is to be set, name - the attribute name, and value - the value to be assigned to the attribute.`,
      errEx: `setattr(None,1,2)`,
    },
    {
      reg: /^bad operand type for unary (.*?): (.*?)(?: on line (\d+))?$/i,
      en: (op, type, line) => `Unary operation ${op} cannot be applied to type '${type}'`,
      enWhen: `This error occurs with incorrect use of unary operations. For example, -"7", +"x", ~1.5.`,
      enFix: `Remove the unary operation or correct the variable's type.`,
      errEx: `-""`,
    },
    {
      reg: /^can only assign an iterable(?: on line (\d+))?$/i,
      en: (line) => `Can only assign an iterable`,
      enWhen: ``,
      enFix: ``,
      errEx: `[1,2,3][1:2]=4`,
    },
    {
      reg: /^can only concatenate (.*) to (.*)(?: on line \d+)?$/i,
      en: (typ1, typ2, line) => `Can only concatenate ${typ1} to ${typ2}`,
      enWhen: `This error occurs when you try to add incompatible objects.`,
      enFix: `Make sure the objects you are adding are of the same type, or can be converted to a common type.`,
      errEx: `[] + 123`,
    },
    {
      reg: /^can\'t convert complex to (.*)(?: on line (\d+))?$/i,
      en: (str, line) => `Cannot convert a complex number to type ${str}`,
      enWhen: ``,
      enFix: `Make sure you are performing a valid operation with the complex number.`,
      errEx: `float(1j)`,
    },
    {
      reg: /^can\'t mod complex numbers.(?: on line (\d+))?$/i,
      en: (line) => `Cannot take the modulo of a complex number`,
      enWhen: ``,
      enFix: `Check your code for correctness.`,
      errEx: `1 % (1+1j)`,
    },
    {
      reg: /^can\'t multiply sequence by non-int of type (.*)(?: on line (\d+))?$/i,
      en: (str, line) => `Cannot multiply a sequence by a non-int of type '${str}'`,
      enWhen: ``,
      enFix: `Check the multipliers. A sequence can only be multiplied by an integer (int).`,
      errEx: `[]*"1"`,
    },
    {
      reg: /^can\'t take floor of complex number.(?: on line (\d+))?$/i,
      en: (line) => `Cannot perform floor division on a complex number`,
      enWhen: ``,
      enFix: `Check your code for correctness.`,
      errEx: `1//1j`,
    },
    {
      reg: /^cannot concatenate 'str' and (.+) objects(?: on line (\d+).?)?$/i,
      en: (str, line) => `Cannot concatenate a string with an object of type '${str}'.`,
      enWhen: `This error occurs when you try to add a non-string (like a number or a list) to a string.`,
      enFix: `Only concatenate strings with other strings. Convert other types to strings first: "foo" + str(10).`,
      errEx: `"" + 123`,
    },
    {
      reg: /^complex\(\) can\'t take second arg if first is a string(?: on line (\d+))?$/i,
      en: (str, line) => `Function ${str} cannot take a second argument if the first is a string`,
      enWhen: ``,
      enFix: ``,
      errEx: `complex("", "")`,
    },
    {
      reg: /^complex\(\) second arg can\'t be (.*)(?: on line (\d+))?$/i,
      en: (line) => `The second argument of the function cannot be of type ${str}`,
      enWhen: `This error occurs when you provide an incorrect argument.`,
      enFix: `Make sure you are passing numeric arguments to the function.`,
      errEx: `complex(1, "")`,
    },
    {
      reg: /^element 0 is not a sequence(?: on line (\d+))?$/i,
      en: (line) => `Element 0 is not a sequence`,
      enWhen: ``,
      enFix: `Types of sequences include: list, tuple, range, string, array.`,
      errEx: `dict((None,))`,
    },
    {
      reg: /^integer argument expected\, got (.*)(?: on line (\d+))?$/i,
      en: (str, line) => `The function expected an integer argument, but got an object of type '${str}'`,
      enWhen: ``,
      enFix: `Make sure the arguments meet the function's requirements.`,
      errEx: `"".replace("","",1.)`,
    },
    {
      reg: /^list indices must be integers, not (.+)(?: on line (\d+).?)?$/i,
      en: (str, line) => `List indices must be integers. '${str}' is not suitable.`,
      enWhen: `This error occurs if you use a non-integer as a list index.`,
      enFix: `Use an integer as the index. For example: my_list[10].`,
      errEx: `[0][1.5]`,
    },
    {
      reg: /^no ordering relation is defined for complex numbers(?: on line (\d+))?$/i,
      en: (line) => ``,
      enWhen: ``,
      enFix: ``,
      errEx: `1+2j > 2+2j`,
    },
    {
      reg: /^object of type (.*) has no len\(\)(?: on line \d+)?$/i,
      en: (str, line) => `Object of type '${str}' has no length`,
      enWhen: ``,
      enFix: ``,
      errEx: `len(reversed([1]))`,
    },
    { // TODO Треш
      reg: /^TypeError\: \'In {2}<(.*)> requires (.*) as left operand(?: on line \d+)?$/i,
      en: (obj, type, line) => `Type error: when using 'in <${obj}>', the left operand must be of type ${type}`,
      enWhen: ``,
      enFix: `Make sure you are using objects of the correct types.`,
      errEx: `1 in "1"`,
    },
    {
      reg: /^unhashable type: (.*)(?: on line (\d+))?$/i,
      en: (str, line) => `Unhashable type: '${str}'`,
      enWhen: `This error occurs when you try to use a mutable object (like a list or dictionary) as a dictionary key.`,
      enFix: `Mutable (changeable) data types cannot be dictionary keys. Use immutable types instead: numbers (int, float, complex), strings (str), tuples, or frozensets. For example, {'one': '1', 2: '2', (3, 4, 5): '345'}.`,
      errEx: `{{}:0}`,
    },
    {
      reg: /^unsupported operand type\(s\) for (.*)\: \'(.*)\' and \'(.*)\'(?: on line \d+)?$/i,
      en: (line) => `Unsupported operand types`,
      enWhen: `This error occurs when you try to perform an operation on two incompatible types, for example, adding a string and an integer.`,
      enFix: `Convert the items to a single type, or use a supported operation. For example, int('123') + 23 or 'abc' * 2.`,
      errEx: `5 + '5'`,
    },
    {
      reg: /^\:keywords must be strings(?: on line \d+)?$/i,
      en: (line) => ``,
      enWhen: ``,
      enFix: ``,
      errEx: `(lambda: None)(**{1: 2})`,
    },
    {
      reg: /^\'(.*)\' not supported between instances of \'(.*)\' and \'(.*)\'(?: on line \d+)?$/i,
      en: (str1, str2, line) => `This operator is not supported between instances of class '${str1}' and '${str2}'`,
      enWhen: ``,
      enFix: ``,
      errEx: `class A:\n    def __cmp__(self, other):\n        return None\nA() < A()`,
    },
    {
      reg: /^Cannot read property \'(.*)\' of null$/i,
      en: (str, line) => `Cannot read property '${str}' of null`,
      enWhen: ``,
      enFix: ``,
      errEx: `{**("key","value")}`,
    },
    {
      reg: /^Inconsistent precedences in type hierarchy(?: on line \d+)?$/i,
      en: (line) => ``,
      enWhen: ``,
      enFix: ``,
      errEx: `class A(object, object): pass`,
    },
    {
      reg: /^(.*)\(\) arg \d+ must be a class\, type\, or tuple of classes and types(?: on line \d+)?$/i,
      en: (str, line) => `The second argument of function ${str} must be a class, a tuple of classes, or a recursive tuple of tuples of classes`,
      enWhen: ``,
      enFix: ``,
      errEx: `isinstance(1, [int])`,
    },
    {
      reg: /^(.*)\(\) arg \d+ must be a class(?: on line \d+)?$/i,
      en: (line) => ``,
      enWhen: ``,
      enFix: ``,
      errEx: `issubclass(1,int)`,
    },
    {
      reg: /^(.*)\(\) arg \d+ must be a class or tuple of classes(?: on line \d+)?$/i,
      en: (line) => ``,
      enWhen: ``,
      enFix: ``,
      errEx: `issubclass(int,[int])`,
    },
    {
      reg: /^must be (.*)\, not (.*)(?: on line \d+)?$/i,
      en: (str, line) => `The optional argument for the function is not '${str}', but the type from which to start searching for the proxy object`,
      enWhen: ``,
      enFix: ``,
      errEx: `super(type,1)`,
    },
    {
      reg: /^(.*) must be a (.*)(?: on line \d+)?$/i,
      en: (line) => ``,
      enWhen: ``,
      enFix: ``,
      errEx: `import math\nclass A:\n    def __float__(self):\n        return "1"\nmath.sin(A())`,
    },
    // Спец. ошибки для модуля ask (см. ask.py)
    {
      reg: /^Ответ на этот вопрос можно сравнивать только со строками или числами(?: on line (\d+).?)?$/i,
      en: (line) => `The answer to this question can only be compared with strings or numbers`,
      enWhen: ``,
      enFix: ``,
    },
    {
      reg: /^ask\(\) missing 1 required argument: question(?: on line (\d+).?)?$/i,
      en: (line) => `Missing argument in the ask function`,
      enWhen: ``,
      enFix: ``,
    },
  ],
  UnboundLocalError: [
    {
      reg: /^local variable (.*) referenced before assignment(?: on line (\d+))?$/i,
      en: (str, line) => `Local variable '${str}' referenced before assignment`,
      enWhen: ``,
      enFix: (str, line) => `First, define the variable and assign it a value, and only then reference it. For example: \n${str} = 1\ndef f():\n    a = 2\n    print(a)\n\nf()`,
      errEx: `a = 1\ndef f():\n    print(a)\n    a = 2\nf()`,
    },
  ],
  ValueError: [
    {
      reg: /^(.*) 2nd argument cannot be negative when 3rd argument specified(?: on line (\d+))?$/i,
      en: (str, line) => `When a third argument is present, the second argument of function ${str} cannot be negative`,
      enWhen: ``,
      enFix: `If the second argument is a negative number, the third argument will not be accepted. If you need to provide a third argument, make sure the first two arguments are positive integers.`,
      errEx: `pow(0, -1, 1)`,
    },
    {
      reg: /^(.*) 3rd argument cannot be 0(?: on line (\d+))?$/i,
      en: (str, line) => `The third argument of function ${str} cannot be 0`,
      enWhen: ``,
      enFix: `The third argument is the number by which the result of the exponentiation is divided (modulo). Make sure it is not zero.`,
      errEx: `pow(0, 0, 0)`,
    },
    {
      reg: /^(.*)\(\) arg is an empty sequence(?: on line \d+)?$/i,
      en: (str, line) => `The argument for function ${str} is an empty sequence`,
      enWhen: ``,
      enFix: (str, line) => `Make sure you are passing a non-empty sequence to the function. You can also check the length of the object before passing it to the ${str} function.`,
      errEx: `max([])`,
    },
    {
      reg: /^(.*) not found(?: on line (\d+))?$/i,
      en: (line) => `Substring not found`,
      enWhen: ``,
      enFix: ``,
      errEx: `"".index("a")`,
    },
    {
      reg: /^(.*) step argument must not be zero(?: on line (\d+))?$/i,
      en: (str, line) => `The step argument for function ${str} cannot be zero`,
      enWhen: ``,
      enFix: `Make sure you use a non-zero step value when creating the sequence.`,
      errEx: `range(0,0,0)`,
    },
    {
      reg: /^(.*)index\(x\)\: x not in (.*)(?: on line (\d+))?$/i,
      en: (line) => `Element x is not in the list`,
      enWhen: `This error occurs when you try to remove an element that is not in the list.`,
      enFix: `Make sure the element you want to remove is in the list. For example:\nmy_list = [1, 3, 2]\nmy_list.remove(1)\n# my_list is now [3, 2]`,
      errEx: `[].remove(1)`,
    },
    {
      reg: /^Attempted relative import in non-package(?: on line (\d+))?$/i,
      en: (line) => `Module import error`,
      enWhen: ``,
      enFix: `Make sure you are importing the function from a specific library. For example, from math import pow.`,
      errEx: `from . import a`,
    },
    {
      reg: /^(.*)\(\) arg not in range\(\d+\)(?: on line \d+)?$/i,
      en: (str, line) => `The maximum value for the argument of function ${str} has been exceeded`,
      enWhen: ``,
      enFix: ``,
      errEx: `chr(10000000000)`,
    },
    {
      reg: /^complex\(\) arg is a malformed string(?: on line \d+)?$/i,
      en: (line) => `Malformed string for complex() argument`,
      enWhen: `This error occurs when an argument is passed incorrectly to the complex() function.`,
      enFix: `Pass integer arguments to the function, or if you are passing a string expression (e.g., complex('1-2j')), make sure there are no spaces around the operator.`,
      errEx: `complex("")`,
    },
    {
      reg: /^empty separator(?: on line (\d+))?$/i,
      en: (line) => ``,
      enWhen: ``,
      enFix: ``,
      errEx: `"".split("")`,
    },
    {
      reg: /^int\(\) base must be >= 2 and <= 36$/i,
      en: (line) => `The base parameter must be between 2 and 36, or 0`,
      enWhen: ``,
      enFix: `The second argument of the int() function specifies the number system of the string in the first argument. Available number systems are from base 2 to base 36.`,
      errEx: `int('10', 40)`,
    },
    {
      reg: /^invalid literal for (.*) with base (.*): (.*)(?: on line (\d+).?)?$/i,
      en: (func, base, liter, line) => `Cannot convert the expression '${liter}' to a number in base ${base} using the ${func} function.`,
      enWhen: `This error occurs when you try to convert an invalid string to a number, for example, int("foo").`,
      enFix: `You should pass a string that represents a number to the int() function, without any extra letters.`,
      errEx: `int("z")`,
    },
    {
      reg: /^need more than (.*) values to unpack(?: on line (\d+).?)?$/i,
      en: (num, line) => `Need more than ${num} values to unpack`,
      enWhen: `This error occurs when you try to assign too few values to multiple variables: a, b, c = [1, 2].`,
      enFix: `Check the number of items in the list/tuple/... and the number of variables you are assigning them to.`,
      errEx: `a, b = [0]`,
    },
    {
      reg: /^negative number cannot be raised to a fractional power(?: on line (\d+).?)?$/i,
      en: (line) => `Cannot raise a negative number to a fractional power`,
      enWhen: `This error occurs when you try to raise a negative number to a power like 0.5, for example: (-2)**0.5.`,
      enFix: `Either make the number positive or make the power an integer.`,
      errEx: `pow(-2, 0.5)`,
    },
    {
      reg: /^negative shift count(?: on line (\d+))?$/i,
      en: (line) => `Bitwise shift operations are not applicable to negative numbers`,
      enWhen: ``,
      enFix: `Use a positive number as the shift value.`,
      errEx: `1<<-1`,
    },
    {
      reg: /^slice step cannot be zero(?: on line (\d+))?$/i,
      en: (line) => `Slice step cannot be zero`,
      enWhen: ``,
      enFix: `Make sure you use a non-zero step value for the slice, as a zero step is not allowed. For example, [1, 2, 3, 4, 5][1:4:2].`,
      errEx: `[][::0]`,
    },
    {
      reg: /^too many values to unpack(?: on line (\d+).?)?$/i,
      en: (line) => `Too many values to unpack`,
      enWhen: `This error occurs when you try to assign too many values to a few variables: a, b = [1, 2, 3].`,
      enFix: `Check the number of items in the list/tuple/... and the number of variables you are assigning them to.`,
      errEx: `a, b = [1, 2, 3]`,
    },
    // Спец. ошибки для модуля ask (см. ask.py)
    {
      reg: /^Ответ на этот вопрос можно только сравнивать с числами 0, 2, 4, 6, 8(?: on line (\d+).?)?$/i,
      en: (line) => `The answer to this question can only be compared with the numbers 0, 2, 4, 6, 8`,
      enWhen: ``,
      enFix: ``,
    },
    {
      reg: /^Ответ на этот вопрос можно сравнивать только с "Y" и "N"(?: on line (\d+).?)?$/i,
      en: (line) => `The answer to this question can only be compared with "Y" and "N"`,
      enWhen: ``,
      enFix: ``,
    },
    {
      reg: /^Ответ на этот вопрос можно сравнивать только при помощи ==(?: on line (\d+).?)?$/i,
      en: (line) => `The answer to this question can only be compared using ==`,
      enWhen: ``,
      enFix: ``,
    },
    {
      reg: /^Ответ на этот вопрос можно только сравнивать с числами(?: on line (\d+).?)?$/i,
      en: (line) => `The answer to this question can only be compared with numbers`,
      enWhen: ``,
      enFix: ``,
    },
  ],
  ZeroDivisionError: [
    {
      reg: /^complex division by zero(?: on line (\d+))?$/i,
      en: (line) => `Division of a complex number by zero`,
      enWhen: `This error occurs when you try to divide by 0.`,
      enFix: ``,
      errEx: `1j/0`,
    },
    {
      reg: /^complex division by zero(?: on line (\d+))?$/i,
      en: (line) => ``,
      enWhen: ``,
      enFix: ``,
      errEx: `0**1j`,
    },
    {
      reg: /^integer division or modulo by zero(?: on line (\d+).?)?$/i,
      en: (line) => `Cannot divide by 0`,
      enWhen: `This error occurs when you try to divide by 0 or take the modulo by 0.`,
      enFix: ``,
      errEx: `1/0`,
    },
  ],
};