export default{AssertionError:[{reg:/^(.*) on line (\d+)$/i,ru:r=>"Ошибка, вызванная assert",ruWhen:"Ошибка возникает, когда проверка в инструкции assert не увенчалась успехом.",ruFix:"Оператор assert используется так: assert boolean_expression, optional_expression. Если boolean_expression возвращает False, возбуждается исключение AssertionError с сообщением optional_expression (если задано).",errEx:"assert 0,0"},{reg:/^ on line (\d+)$/i,ru:r=>"Ошибка, вызванная assert",ruWhen:"Ошибка возникает, когда проверка в инструкции assert не увенчалась успехом.",ruFix:"Оператор assert используется так: assert boolean_expression, optional_expression. Если boolean_expression возвращает False, возбуждается исключение AssertionError с сообщением optional_expression (если задано).",errEx:"assert False"}],AttributeError:[{reg:/^(.*?) object has no attribute (.*?) on line (\d+)$/i,ru:(r,e,n)=>`У объекта типа ${r} нет атрибута ${e}`,ruWhen:'Ошибка возникает при использовании атрибута или метода, которого у данного объекта нет. Например: "a".leng()',ruFix:'Проверьте имя атрибута/метода. Возможно, вместо метода нужно использовать функцию ("a".len() -> len("a"))',errEx:"{}.a()"}],Error:[{reg:/^Assertion failure\: (.*)$/i,ru:r=>"",ruWhen:"",ruFix:"",errEx:"class A: pass\ndel A.__dict__"}],Exception:[{reg:/^ on line \d+$/i,ru:r=>"",ruWhen:"",ruFix:"",errEx:"raise Exception from 1"}],ExternalError:[{reg:/^.*haven't implemented non-read opens on line (\d+)$/i,ru:r=>"Запись в файлы не поддерживается",ruWhen:"Ошибка возникает при попытке выполнить запись в файл",ruFix:"Не используйте запись в файл в web-версии интерпретатора",errEx:"open(\"/a\", 'w')"},{reg:/^(.*) is not a constructor on line (\d+)$/i,ru:(r,e)=>`${r} не является конструктором`,ruWhen:"",ruFix:"",errEx:"object.__new__(1)"},{reg:/^TypeError\: Cannot read property \'(.*)\' of undefined on line \d+$/i,ru:r=>"Функция type() ожидает строго 1 или 3 аргумента",ruWhen:"Ошибка возникает при указании неправильного количества аргументов.",ruFix:"Проверьте количество аргументов: их должно быть 1 или 3. Например, type(1).",errEx:"type(0,0)"},{reg:/^RangeError: Maximum call stack size exceeded on line undefined$/i,ru:r=>"",ruWhen:"",ruFix:"",errEx:"a = lambda x: a(x); a(a)"},{reg:/^TypeError\: (.*)\(\w+\, \w+\)\: (.*) must be callable on line \d+$/i,ru:(r,e,n)=>`Первый аргумент ${r} функции ${e} должен быть вызываемым`,ruWhen:"Ошибка возникает в случае, когда при передаче двух аргументов, первый не является вызываемым (функцией)",ruFix:"",errEx:"iter(1,2)"},{reg:/^\[.*\] on line \d+$/i,ru:r=>"",ruWhen:"",ruFix:"",errEx:"raise 1"},{reg:/^TypeError\: Cannot read property \'(.*)\' of (.*) on line \d+$/i,ru:(r,e,n)=>`Ошибка типа: неудается прочитать свойство ${r} объекта ${e}`,ruWhen:"",ruFix:"",errEx:'"%*d"%""'}],IOError:[{reg:/^\[Errno 2\] No such file or directory: \'(.*)\' on line \d+$/i,ru:(r,e)=>`Не существует файла ${r}`,ruWhen:"В веб-версии интерпретатора можно читать только файлы, явно указанные в условиях",ruFix:"Проверьте, что имя файла для чтения совпадает с именем в условиях.",errEx:"open('.')"}],ImportError:[{reg:/^No module named (\w+) on line (\d+).?$/i,ru:(r,e)=>`Модуля ${r} не существует.`,ruWhen:"Ошибка возникает при импортировании модуля, которого не существует.",ruFix:"Импортируйте существующие модули: drawzero, time и т.п.",errEx:"import z"}],IndexError:[{reg:/^list assignment index out of range on line (\d+)$/i,ru:r=>"Индекс элемента, которому присваивается значение, вне диапазона",ruWhen:"Ошибка возникает, когда присваем значение несуществующему элементу",ruFix:"Убедитесь, что индекс указан правильно и не выходит за рамки возможных значений. Например, [1,2][0]=0",errEx:"[][0]=0"},{reg:/^list index out of range on line (\d+).?$/i,ru:r=>"Индекс списка больше или равен его длине.",ruWhen:"Ошибка возникает при взятии элемента списка по номеру большему или равному длине списка.",ruFix:"Укажите номер поменьше. Помните, что нумерация с 0.",errEx:"[0][1]"},{reg:/^pop index out of range on line (\d+).?$/i,ru:r=>"Номер для извлечения элемента из списка больше его длины",ruWhen:"Ошибка возникает при выполнении pop() для пустого списка при pop(n) при n ⩾ длины списка",ruFix:"Убедитесь, что список не пуст или укажите номер поменьше. Помните, что нумерация с 0.",errEx:"[].pop()"},{reg:/^string index out of range on line (\d+).?$/i,ru:r=>"Индекс элемента строки вне диапазона",ruWhen:"Ошибка возникает, когда по индексу запрашивается элемент, отсутствующий в объекте",ruFix:"Убедитесь в наличии искомого элемента. Например, 'abc'[0]",errEx:'""[1]'},{reg:/^tuple index out of range on line (\d+).?$/i,ru:r=>"Индекс элемента кортежа вне диапазона",ruWhen:"Ошибка возникает, когда по индексу запрашивается элемент, отсутствующий в кортеже",ruFix:"Убедитесь в наличии искомого элемента. Например, (1,2,3)[1]",errEx:"(1,)[2]"}],KeyError:[{reg:/^(.*?) on line (\d+)$/i,ru:(r,e)=>`Ключа ${r} нет в словаре.`,ruWhen:"",ruFix:"Убедитесь, что ключ есть в словаре. При необходимости можно проверить, что он есть: key in my_dict, или указать значение по умолчанию my_dict.get(key, default)",errEx:"{}[0]"},{reg:/^pop from an empty set on line (\d+)$/i,ru:r=>"Ошибка удаления из пустого множества",ruWhen:"",ruFix:"Убедитесь, что объект, к которому применяется pop(), не является пустым",errEx:"set().pop()"}],NameError:[{reg:/^name '(.*?)' is not defined on line (\d+)$/i,ru:(r,e)=>`Переменная ${r} не объявлена`,ruWhen:"Ошибка возникает при использовании необъявленной переменной",ruFix:(r,e)=>`Объявите эту переменную, например: ${r} = 10`,errEx:"__builtins__.__build_class__(1,2)"}],NegativePowerError:[{reg:/^cannot raise a negative number to a fractional power on line \d+$/i,ru:r=>"Нельзя возводить отрицательное число в нецелую степень",ruWhen:"Ошибка возникает при попытке возвести отрицательное число в степень, например (-2)**0.5",ruFix:"Сделайте либо число положительным, либо степень целой.",errEx:"(-2)**0.5"},{reg:/^cannot raise zero to a negative power on line (\d+).?$/i,ru:r=>"Нельзя возводить 0 в отрицательную степень",ruWhen:"Ошибка возникает при попытке возвести 0 в отрицательную степень",ruFix:"Сделайте либо число положительным, либо степень положительной. Например, 1 ** 3 или -3 ** 6",errEx:"0**-2"},{reg:/^cannot raise zero to a negative power on line (\d+).?$/i,ru:r=>"Нельзя возводить 0 в отрицательную степень",ruWhen:"Ошибка возникает при попытке возвести 0 в отрицательную степень.",ruFix:"Сделайте либо число положительным, либо степень положительной.",errEx:"0**-2"}],NotImplementedError:[{reg:/^(.*?) is not yet implemented.*?on line (\d+)$/i,ru:(r,e)=>`Команда ${r} в данный момент не поддерживается.`,ruWhen:"Ошибка возникает, при попытке использовать команды, которые не поддерживаются в нашем курсе.",ruFix:"Придумайте, как решить задачу без использования этой команды.",errEx:"from __future__ import braces"}],OverflowError:[{reg:/^absolute value too large on line (\d+)$/i,ru:r=>"Модуль числа превышает допустимый размер",ruWhen:"Модуль числа превышает 10³⁰⁸ и не помещается в тип float",ruFix:"",errEx:"abs((1+1j)*10**308*1.3)"},{reg:/^Numerical result out of range on line (\d+)$/i,ru:r=>"Числовой результат слишком большой",ruWhen:"Ошибка возникает, когда результат вычислений превышает допустимый размер",ruFix:"Используйте числа поменьше или уменьшите количество математических операций",errEx:"10.0 ** 10.0 ** 10.0"}],RuntimeError:[{reg:/^(.*) no arguments on line (\d+)$/i,ru:(r,e)=>`Отсутствуют аргументы функции ${r} `,ruWhen:"Ошибка возникает, когда функция не получает аргументов.",ruFix:"Укажите аргументы функции",errEx:"super()"}],StopIteration:[{reg:/^ on line (\d+)$/i,ru:r=>"Итератор исчерпал доступные значения",ruWhen:"",ruFix:"",errEx:"next(iter([]))"}],SyntaxError:[{reg:/^(.*) outside function$/i,ru:(r,e)=>`${r} вне тела функции`,ruWhen:(r,e)=>`Ошибка возникает, когда ${r} используется вне тела функции`,ruFix:(r,e)=>`Убедитесь, что инструкция ${r} находится внутри тела функции. Проверьте наличие функции и отступы`,errEx:"return"},{reg:/^(.*) outside loop$/i,ru:(r,e)=>`${r} вне цикла`,ruWhen:(r,e)=>`Ошибка возникает, когда ${r} используется вне цикла`,ruFix:(r,e)=>`Убедитесь, что инструкция ${r} находится внутри тела цикла. Проверьте наличие цикла и отступы`,errEx:"break"},{reg:/^(.*) outside loop$/i,ru:(r,e)=>`${r} вне цикла`,ruWhen:(r,e)=>`Ошибка возникает, когда ${r} используется вне цикла`,ruFix:(r,e)=>`Убедитесь, что инструкция ${r} находится внутри тела цикла. Проверьте наличие цикла и отступы`,errEx:"continue"},{reg:/^\'(.*)\' with argument inside generator at$/i,ru:(r,e)=>`${r} внутри генератора`,ruWhen:"",ruFix:"Используйте yield и return без выражения",errEx:"def f():\n    yield\n    return 1"},{reg:/^annotated name (.*) can't be global on line (\d+)$/i,ru:(r,e)=>`Аннотированная переменная ${r} не может быть глобальной`,ruWhen:"",ruFix:"Проверьте корректность кода",errEx:"def f():\n    global a\n    a: int = 1"},{reg:/^illegal target for annotation on line \d+$/i,ru:r=>"Синтаксическая ошибка",ruWhen:"Ошибка возникает, если код некорректен",ruFix:"Проверьте скобки и отступы, это — наиболее частые ошибки",errEx:"f(): int"},{reg:/^bad input on line (\d+).?$/i,ru:r=>"Синтаксическая ошибка.",ruWhen:"Ошибка возникает, если код некорректен",ruFix:"Проверьте скобки и отступы, это — наиболее частые ошибки",errEx:"def a(): await a()"},{reg:/^can\'t assign to (.*) on line \d+$/i,ru:r=>"Синтаксическая ошибка",ruWhen:"Ошибка возникает, если код некорректен",ruFix:"Скорее всего, в коде некорректный символ (например, $)",errEx:"() = 1"},{reg:/^bad token.*on line (\d+).?$/i,ru:r=>"Синтаксическая ошибка.",ruWhen:"Ошибка возникает, если код некорректен",ruFix:"Скорее всего, в коде некорректный символ (например, $ или русская буква)",errEx:"$"},{reg:/^can\'t assign to (.*) expression on line (\d+)$/i,ru:(r,e)=>`Невозможно присвоить значение ${r}`,ruWhen:"",ruFix:"",errEx:"(yield)=1"},{reg:/^can\'t assign to function call on line (\d+)$/i,ru:r=>"Невозможно выполнить вызов функции",ruWhen:"Ошибка вызывает при некорректном вызове функции",ruFix:"Скорее всего, код вызова данной функции записан некорректно",errEx:"id() = 1"},{reg:/^can\'t assign to literal on line (\d+)$/i,ru:r=>"Невозможно присвоить значение литералу",ruWhen:"",ruFix:"Убедитесь, что  слева от оператора присваивания наход. Например, a = 1",errEx:"1=1"},{reg:/^can\'t assign to operator on line (\d+)$/i,ru:r=>"Нельзя присвоить значение оператору",ruWhen:"Ошибка возникает при некорректном присвоении значения или при некорректном имени переменной",ruFix:'Убедитесь, что слева от оператора присваивания "=" находится переменная. Также убедитесь, что в названии переменной нет знаков *, +, -, /. ',errEx:"-1=1"},{reg:/^can\'t assign to True, False or None on line (\d+)$/i,ru:r=>"Для True, False или None невозможно присвоить значение",ruWhen:"",ruFix:'Убедитесь, что слева от оператора присваивания "=" находится переменная. Слова True, False, None не могут быть названиями переменных',errEx:"True = False"},{reg:/^can\'t delete function call on line (\d+)$/i,ru:r=>"Невозможно удалить вызов функции",ruWhen:"",ruFix:"",errEx:"del id()"},{reg:/^default (.*) must be last$/i,ru:(r,e)=>`Блок ${r} должен следовать последним`,ruWhen:"Ошибка возникает, когда при записи составной конструкции try - except последним записывается не блок except",ruFix:"Убедитесь в правильности написания конструкции для обработки исключений. Например, \ntry:\n    pass\nexcept:\n    pass",errEx:"try:\n    pass\nexcept:\n    pass\nexcept 1:\n    pass"},{reg:/^duplicate argument \'(.*)\' in function definition on line (.*)$/i,ru:(r,e)=>`Повторяющийся аргумент ${r} в определении функции`,ruWhen:"Ошибка возникает, когда в функцию передаётся аргумент несколько раз.",ruFix:"Убедитесь, что аргументы в функции записаны правильно. Например, def q(a,b): pass",errEx:"def f(a,a): pass"},{reg:/^EOF in multi-line string on line (\d+)$/i,ru:r=>"Ошибка при обработке тройных кавычек",ruWhen:"Ошибка возникает при неправильном использовании кавычек. Возможно,  строка началась с тройных кавычек, но не закончилась.",ruFix:'Проверь правильность использования кавычек. Основные способы: 1) При написании строки: \'abc\' или "abc". 2) При документировании: например, """ Эта функция работает так """',errEx:'"""'},{reg:/^Invalid or unexpected token$/i,ru:r=>"Синтаксическая ошибка",ruWhen:"Ошибка возникает, если в коде некорректеный символ",ruFix:"Скорее всего, в коде некорректный символ (например, №)",errEx:"№"},{reg:/^invalid string \(.*\) on line \d+$/i,ru:r=>"Синтаксическая ошибка",ruWhen:"Ошибка возникает, если в коде некорректный символ",ruFix:"Скорее всего, в коде некорректный символ (например, №)",errEx:"f'{}'"},{reg:/^keyword argument repeated on line (\d+)$/i,ru:r=>"Синтаксическая ошибка: повторение аргумента",ruWhen:"Ошибка возникает при передаче нескольких одинаковых аргументов",ruFix:"Проверьте передаваемые аргументы. Помните, что повторяться они не должны. Например, f(a = 1, b = 2)",errEx:"f(a=1,a=1)"},{reg:/^name \'(.*)\' is assigned to before global declaration on line \d+$/i,ru:(r,e)=>`Переменной ${r} присвоено значение перед объявлением её глобальной`,ruWhen:"",ruFix:"Убедитесь, что объявление глобальной переменной находится до любых действий с ней. ",errEx:"def f():\n    a = 1\n    global a"},{reg:/^named arguments must follow bare \* on line (\d+)$/i,ru:r=>"После '*' должны следовать  аргументы",ruWhen:"",ruFix:"",errEx:"def f(*): pass"},{reg:/^non-default argument follows default argument on line (\d+)$/i,ru:r=>"Аргументы не по умолчанию должны идти после аргументов по умолчанию",ruWhen:"",ruFix:"Убедись, что параметры, которым присваивается значение по-умолчанию следуют за параметрами, не имеющими значений по умолчанию. Например, def w(a, c = 4): , где a - параметр, не имеющий значения по умолчанию, а c - параметр со значением 4 по умолчанию",errEx:"def f(a=1, b): pass"},{reg:/^trailing comma not allowed without surrounding parentheses on line (\d+)$/i,ru:r=>"Завершающая запятая не допускается без круглых скобок",ruWhen:"",ruFix:"Убедись, что в коде нет лишних запятых. Либо, если запятая необходима, используйте круглые скобки.",errEx:"from a import b, c,"},{reg:/^(.*) unpacking with stars is not supported at (.*)$/i,ru:(r,e)=>`Невозможно распаковать объект типа ${r} с использованием * `,ruWhen:"",ruFix:"",errEx:"*a, *a = a"},{reg:/^Unexpected token \'(.*)\'$/i,ru:(r,e)=>`Используется неподходящий сивол ${r}`,ruWhen:"Возможно, в строке допущена опечатка",ruFix:"Убедитесь, что в коде нет лишних сиволов",errEx:"a = *a"}],TimeLimitError:[{reg:/^Program exceeded run time limit. on line (\d+).$/i,ru:r=>"Программа выполняется слишком долго.",ruWhen:"Ошибка часто возникает при возникновении бесконечных циклов или слишком сложных вычислениях.",ruFix:"Проверьте условия выхода из цикла, сделайте решение эффективнее.",errEx:"for i in range(10**6): i = i"}],TypeError:[{reg:/^(.*?) object is not iterable on line (\d+).?$/i,ru:(r,e)=>`Нельзя итерироваться по объекту типа ${r}`,ruWhen:"Ошибка возникает при попытке пройти в цикле по числу (for i in 5) или «распаковать» число (a, b = 5), или по другому не подходящему типу.",ruFix:"Делайте итерацию по спискам/кортежам/словарям/множествам/строкам, а не по числам.",errEx:"class A():\n    pass\niter(A())"},{reg:/^(.*)\(\) takes at least \d+ arguments \(\d+ given\) on line \d+$/i,ru:(r,e,n,i)=>`Функция ${r} требует хотя бы ${e} параметр(ов), а передан(ы) ${n}`,ruWhen:"Ошибка возникает, когда в функцию передано недостаточно параметров. Например, int().",ruFix:"Добавьте недостающие параметры.",errEx:"{}.fromkeys()"},{reg:/^(.*) 3rd argument not allowed unless all arguments are integers on line (\d+)$/i,ru:(r,e)=>`Если первые два аргумента функции ${r} - не целые числа, и второй аргумент не является положительным числом, третий аргумент не принимается`,ruWhen:"",ruFix:(r,e)=>`Убедитесь, что функции ${r} передаются целочисленные аргументы, и второй аргумент не является отрицательным. `,errEx:"pow(1., 0, 0)"},{reg:/^(.*) arg must be None or str on line (\d+)$/i,ru:(r,e)=>`Аргументом функции ${r} может быть объект типа str или None.`,ruWhen:"",ruFix:" Убедитесь, что аргументы записаны верно",errEx:'"1x".lstrip(1)'},{reg:/^(.*) argument 1 must be str, not int on line (\d+)$/i,ru:(r,e,n,i)=>`Первым аргументом функции ${r} должен быть объект типа ${e}, а не объект типа ${n}`,ruWhen:"",ruFix:(r,e,n,i)=>`Исправьте аргументы функции ${r}`,errEx:"type(123, (), {})"},{reg:/^(.*) argument 2 must be tuple, not list on line (\d+)$/i,ru:(r,e,n,i)=>`Вторым аргументом функции ${r} должен быть объект типа ${e}, а не объект типа ${n}`,ruWhen:"",ruFix:(r,e,n,i)=>`Исправьте аргументы функции ${r}`,errEx:'type("ClassName", [], {})'},{reg:/^(.*) argument 3 must be dict, not NoneType on line (\d+)$/i,ru:(r,e,n,i)=>`Третьим аргументом функции ${r} должен быть объект типа ${e}, а не объект типа ${n}`,ruWhen:"",ruFix:(r,e,n,i)=>`Исправьте аргументы функции ${r}`,errEx:'type("ClassName", (), None)'},{reg:/^(.*)\(\) argument can\'t be converted to (.*) on line (\d+)$/i,ru:(r,e,n)=>`Аргумент функции ${r} не может быть преобразован к типу ${e}`,ruWhen:"Ошибка возникает при попытке передачи функции не целочисленного объекта",ruFix:"",errEx:'hex("abc")'},{reg:/^(.*) argument must be a string or a number, not (.*?) on line (\d+)$/i,ru:(r,e,n)=>`Агрумент функции ${r} должен быть строкой или числом, ${e} не подходит.`,ruWhen:(r,e)=>`Ошибка возникает при попытке превратить в число функцией ${r} неправильный объект.`,ruFix:'Убедитесь, что передаёте в int строку или число (например, int("1") или int(1.5))',errEx:"int(None)"},{reg:/^(.*) argument must be a string or number on line (\d+)$/i,ru:(r,e)=>`Аргумент конструктора ${r} должен быть строкой или числом`,ruWhen:"",ruFix:"Проверьте передаваемые аргументы",errEx:"complex(None)"},{reg:/^(.*) attribute name must be (.*) on line (\d+)$/i,ru:(r,e)=>`Атрибут функции name должен быть объектом типа ${r}`,ruWhen:"",ruFix:"",errEx:"hasattr(1,2)"},{reg:/^(.*) can\'t convert non-string with explicit base on line (\d+)$/i,ru:(r,e)=>`Функция ${r} не может конвертировать объект, не являющийся строкой, с явно определенным основанием`,ruWhen:(r,e)=>`Ошибка возникает при попытке превратить в число функцией ${r} неправильный объект.`,ruFix:'Убедитесь, что первым параметром передаёте в int() строку, а вторым - число. Например, int("123", 10)',errEx:"int(0,0)"},{reg:/^(.*) can\'t sum strings \[use \'\'\.join\(seq\) instead\] on line (\d+)$/i,ru:(r,e)=>`Функция ${r} не может сложить строки (используйте ''.join(последовательность))`,ruWhen:"",ruFix:"Для сложения строк используйте метод join(), а функцию sum() используйте с итерируемыми объектами, состоящими из чисел. Например, '.'.join(['1','2']) или sum([1, 2]).",errEx:'sum([],"")'},{reg:/^(.*) does not support indexing on line (\d+)$/i,ru:(r,e)=>`К объекту типа ${r} нельзя обратиться по индексу`,ruWhen:(r,e)=>`Ошибка возникает при попытке обратиться к элементу типа ${r} по индексу`,ruFix:"Убедитесь, что индексы используются только у тех элементов, которые их имеют.",errEx:"1[1]"},{reg:/^(.*) does not support item assignment on line (\d+)$/i,ru:(r,e)=>`Объект типа ${r} не поддерживает присваивание значения`,ruWhen:"",ruFix:(r,e)=>`Убедитесь, что не пытаетесь присвоить значение элементу неизменяемого типа ${r} `,errEx:"1[1]=1"},{reg:/^(.*) expected a character, but string of length (\d+) found on line (\d+)$/i,ru:(r,e,n)=>`Функция ${r} ожидает получить символ, а получила строку длиной ${e}`,ruWhen:"",ruFix:(r,e,n)=>`Убедитесь, что функция ${r} принимает на вход строку, состоящую из одного символа.`,errEx:'ord("ab")'},{reg:/^(.*) got an unexpected keyword argument (.*) on line (\d+).?$/i,ru:(r,e,n)=>`У ${r} нет именованного параметра ${e}.`,ruWhen:"Ошибка возникает при передаче именованного параметра, которого быть не должно",ruFix:"Проверьте имя параметра и параметры функции/метода.",errEx:"int(z=1)"},{reg:/^(.*) indices must be integers or None on line (\d+)$/i,ru:(r,e)=>`Индексы объекта ${r} должны быть целочисленными или типа None`,ruWhen:"",ruFix:"",errEx:'""[.2:.2]'},{reg:/^(.*) indices must be integers, not float on line (\d+)$/i,ru:(r,e)=>`Индексы объекта ${r} должны быть целочисленными, а не дробными`,ruWhen:"",ruFix:"",errEx:'""[1.2]'},{reg:/^(.*) must be None or a string, not int on line (\d+)$/i,ru:(r,e)=>`Значением разделителя ${r} должно быть либо None, либо строка, но не целое число`,ruWhen:"",ruFix:(r,e)=>`Проверьте значение, передаваемое разделителю ${r}. Например, print(a, b, c, d, sep = '+').`,errEx:"print(end=1)"},{reg:/^(.*) must return (.*) on line (\d+)$/i,ru:(r,e,n)=>`Метод ${r} должен возвращать объект типа ${e}`,ruWhen:"",ruFix:"",errEx:"class A:\n    def __dir__(self):\n        return 1\ndir(A())"},{reg:/^(.*) object cannot be interpreted as an integer on line (\d+)$/i,ru:(r,e)=>`${r} объект не может быть представлен как целое число`,ruWhen:"Ошибка возникает, когда вместо целого числа объект NoneType",ruFix:"",errEx:"class A:\n    def __len__(self):\n        return None\nlen(A())"},{reg:/^(.*) object does not support item deletion on line (\d+)$/i,ru:(r,e)=>`Объект ${r} не поддерживает удаление значения`,ruWhen:"",ruFix:"",errEx:"del {1,2,3}[1:2]"},{reg:/^(.*) object is not a sequence on line (\d+)$/i,ru:(r,e)=>`Объект типа ${r} не является последовательностью`,ruWhen:" Ошибка возникает при попытке передачи функции объекта, не являющего последовательностью",ruFix:"Виды последовательностей: список, кортеж, диапазон, строка, массив. ",errEx:"reversed(1)"},{reg:/^(.*) object is not callable on line (\d+)$/i,ru:(r,e)=>`Объект ${r} не вызывается`,ruWhen:"Ошибка возникает при попытке вызвать объект, который не вызывается",ruFix:(r,e)=>`Убедитесь, что нигде нет лишних скобок и операции с объектами типа ${r} выполняются корректно.`,errEx:"()()"},{reg:/^(.*) object is not iterable on line (\d+).?$/i,ru:r=>"Нельзя итерироваться по целому числу",ruWhen:"Ошибка возникает при попытке пройти в цикле по числу (for i in 5) или «распаковать» число (a, b = 5)",ruFix:"Делайте итерацию по спискам/кортежам/словарям/множествам/строкам, а не по числам",errEx:"a, b = 5"},{reg:/^(.*) returned non-(.*) (.*) on line (\d+)$/i,ru:(r,e,n,i)=>`Метод ${r} возвращает объект типа ${e} вместо ${n}`,ruWhen:"",ruFix:"",errEx:"class A:\n    def __index__(self):\n        return 1.5\n[][A()]"},{reg:/^(.*) should return (.*) on line (\d+)$/i,ru:(r,e,n)=>`Метод ${r} должен возвращать объект типа ${e}`,ruWhen:"",ruFix:"",errEx:'class A:\n    def __complex__(self):\n        return "1+2j"\ncomplex(A())'},{reg:/^(.*) should return (.*), returned (.*) on line (\d+)$/i,ru:(r,e,n,i)=>`Метод ${r} должен возвращать объект типа ${e} вместо ${n}`,ruWhen:"",ruFix:"",errEx:'class A:\n    def __bool__(self):\n        return "yes"\nnot A()'},{reg:/^(.*) should return (.*), not (.*) on line (\d+)$/i,ru:(r,e,n,i)=>`Метод ${r} должен возвращать объект типа ${e} вместо ${n}`,ruWhen:"",ruFix:"",errEx:"class A:\n    def __init__(self):\n        return {}\nA()"},{reg:/^(.*)\(\) takes \d+ positional arguments but \d+ were given on line (\d+)$/i,ru:(r,e,n,i)=>`У функции ${r} всего ${e} параметров, а переданы ${n}.`,ruWhen:"Ошибка возникает при передаче слишком большого числа параметров.",ruFix:"Проверьте параметры функции/метода и то, как они вызываются.",errEx:"int(1, 2, 3)"},{reg:/^(.*)\(\) takes at most (\d+) arguments \((\d+) given\) on line (\d+)$/i,ru:(r,e,n,i)=>`У функции ${r} всего ${e} параметров, а переданы ${n}.`,ruWhen:"Ошибка возникает при передаче слишком большого числа параметров.",ruFix:"Проверьте параметры функции/метода и то, как они вызываются.",errEx:"str(1, 2)"},{reg:/^attribute name must be (.*) on line (\d+)$/i,ru:(r,e,n)=>`Атрибут ${r} должен быть объектом типа ${e}`,ruWhen:"Ошибка возникает при некорректной передаче параметров функции",ruFix:(r,e,n)=>`Функция ${r} принимает 3 параметра: object - объект, атрибут которого должен быть установлен, name - имя атрибута, value - значение, данное атрибуту. `,errEx:"setattr(None,1,2)"},{reg:/^bad operand type for unary (.*?): (.*?) on line (\d+)$/i,ru:(r,e,n)=>`Унарную операцию ${r} нельзя применять к типу ${e} `,ruWhen:'Ошибка возникает при некорректном использовании унарных операций. Например, -"7", +"x", ~1.5',ruFix:"Удилите унарную операцию или исправьте тип переменной",errEx:'-""'},{reg:/^can only assign an iterable on line (\d+)$/i,ru:r=>"В качестве присваиваемого значения можно использовать только итерируемый объект",ruWhen:"",ruFix:"",errEx:"[1,2,3][1:2]=4"},{reg:/^can only concatenate (.*) to (.*) on line \d+$/i,ru:(r,e,n)=>`Можно сложить только ${r} и ${e} `,ruWhen:"Ошибка возникает при попытке сложения нескладываемых объектов",ruFix:"Убедитесь, что складываемые объекты приведены к единому типу",errEx:"[] + 123"},{reg:/^can\'t convert complex to (.*) on line (\d+)$/i,ru:(r,e)=>`Невозможно привести комплексное число к типу ${r}`,ruWhen:"",ruFix:"Убедитесь, что выполняете верную операцию с комплексным числом",errEx:"float(1j)"},{reg:/^can\'t mod complex numbers. on line (\d+)$/i,ru:r=>"Невозможно взять остаток от деления на комплексное число",ruWhen:"",ruFix:"Проверьте корректность написания кода",errEx:"1 % (1+1j)"},{reg:/^can\'t multiply sequence by non-int of type (.*) on line (\d+)$/i,ru:(r,e)=>`Невозможно умножить последовательность на объект типа ${r}`,ruWhen:"",ruFix:"Проверьте корректность множителей при умножении. Последовательность можно умножать только на элементы типа int.\n",errEx:'[]*"1"'},{reg:/^can\'t take floor of complex number. on line (\d+)$/i,ru:r=>"Невозможно делить нацело на комплексное число",ruWhen:"",ruFix:"Проверьте корректность написания кода",errEx:"1//1j"},{reg:/^cannot concatenate 'str' and (.+) objects on line (\d+).?$/i,ru:(r,e)=>`К строке нельзя приклеить объект типа ${r}.`,ruWhen:"Ошибка возникает при попытке приклеть к строке не строку, а число или список",ruFix:'Склеивайте только строки: "foo" + str(10)',errEx:'"" + 123'},{reg:/^complex\(\) can\'t take second arg if first is a string on line (\d+)$/i,ru:(r,e)=>`Функция ${r} не может принять второй аргумент, если первый является строкой`,ruWhen:"",ruFix:"",errEx:'complex("", "")'},{reg:/^complex\(\) second arg can\'t be (.*) on line (\d+)$/i,ru:r=>"Вторым аргументом функции не может быть объект типа %{str}",ruWhen:"Ошибка возникает при попытке указать некорректный аргумент",ruFix:"Убедитесь, что передаёте числовые аргументы функции",errEx:'complex(1, "")'},{reg:/^element 0 is not a sequence on line (\d+)$/i,ru:r=>"Нулевой по счёту элемент не является последовательностью",ruWhen:"",ruFix:"Виды последовательностей: список, кортеж, диапазон, строка, массив. ",errEx:"dict((None,))"},{reg:/^integer argument expected\, got (.*) on line (\d+)$/i,ru:(r,e)=>`Функция ожидает на вход целое число, а получила объект типа ${r}`,ruWhen:"",ruFix:"Убедись, что аргументы соответствуют требованиям функции.",errEx:'"".replace("","",1.)'},{reg:/^list indices must be integers, not (.+) on line (\d+).?$/i,ru:(r,e)=>`Индекс массива должен быть целым. ${r} не подходит.`,ruWhen:"Ошибка возникает, если указать в качестве индекса списка не целое число.",ruFix:"Укажите в качестве индекса целое число. Примерно так: my_list[10]",errEx:"[0][1.5]"},{reg:/^no ordering relation is defined for complex numbers on line (\d+)$/i,ru:r=>"",ruWhen:"",ruFix:"",errEx:"1+2j > 2+2j"},{reg:/^object of type (.*) has no len\(\) on line \d+$/i,ru:(r,e)=>`Объект типа ${r} не имеет длины`,ruWhen:"",ruFix:"",errEx:"len(reversed([1]))"},{reg:/^TypeError\: \'In {2}<(.*)> requires (.*) as left operand on line \d+$/i,ru:(r,e,n)=>`Ошибка типа: при использовании конструкции in <${r}> слева должен быть элемент типа ${e} `,ruWhen:"",ruFix:"Убедитесь, что используете объекты правильных типов",errEx:'1 in "1"'},{reg:/^unhashable type: (.*) on line (\d+)$/i,ru:(r,e)=>`Нехешируемый тип ${r}`,ruWhen:"Ошибка возникает при попытке использования словаря в качестве ключа другого словаря",ruFix:"Изменяемые типы данных не могут быть ключами словаря, поэтому воспользуйтесь неизменяемыми типами объектов: числовые данные (int, float, complex), символьные строки (class 'str'), кортежи (tuple), множества (frozenset). Например, {'one': '1', 2: '2', (3, 4, 5): '345'}",errEx:"{{}:0}"},{reg:/^unsupported operand type\(s\) for (.*)\: \'(.*)\' and \'(.*)\ on line \d+$/i,ru:r=>"Неподдерживаемые типы операндов",ruWhen:"Ошибка возникает при попытке объединения двух несовместимых объектов. Например, строки и целого числа.",ruFix:"Приведите элементы к единому типу, либо используйте поддерживаемые действия с объектами. Например, int('123') + 23 или 'abc' * 2.",errEx:"5 + '5'"},{reg:/^\:keywords must be strings on line \d+$/i,ru:r=>"",ruWhen:"",ruFix:"",errEx:"(lambda: None)(**{1: 2})"},{reg:/^\'(.*)\' not supported between instances of \'(.*)\' and \'(.*)\' on line \d+$/i,ru:(r,e,n)=>`Данный символ не поддерживается между экземплярами класса ${r} и ${e}`,ruWhen:"",ruFix:"",errEx:"class A:\n    def __cmp__(self, other):\n        return None\nA() < A()"},{reg:/^Cannot read property \'(.*)\' of null$/i,ru:(r,e)=>`Невозможно прочитать свойство ${r} с нулевым значением`,ruWhen:"",ruFix:"",errEx:'{**("key","value")}'},{reg:/^Inconsistent precedences in type hierarchy on line \d+$/i,ru:r=>"",ruWhen:"",ruFix:"",errEx:"class A(object, object): pass"},{reg:/^(.*)\(\) arg \d+ must be a class\, type\, or tuple of classes and types on line \d+$/i,ru:(r,e)=>`Вторым аргументом функции ${r} может быть только класс, либо кортеж с классами, либо рекурсивный кортеж кортежей`,ruWhen:"",ruFix:"",errEx:"isinstance(1, [int])"},{reg:/^(.*)\(\) arg \d+ must be a class on line \d+$/i,ru:r=>"",ruWhen:"",ruFix:"",errEx:"issubclass(1,int)"},{reg:/^(.*)\(\) arg \d+ must be a class or tuple of classes on line \d+$/i,ru:r=>"",ruWhen:"",ruFix:"",errEx:"issubclass(int,[int])"},{reg:/^must be (.*)\, not (.*) on line \d+$/i,ru:(r,e)=>`В качестве необязательного аргумента функция принимает не ${r}, а тип, от которого следует начать поиск объекта-посредника`,ruWhen:"",ruFix:"",errEx:"super(type,1)"},{reg:/^(.*) must be a (.*) on line \d+$/i,ru:r=>"",ruWhen:"",ruFix:"",errEx:'import math\nclass A:\n    def __float__(self):\n        return "1"\nmath.sin(A())'},{reg:/^Ответ на этот вопрос можно сравнивать только со строками или числами on line (\d+).?$/i,ru:r=>"Ответ на этот вопрос можно сравнивать только со строками или числами",ruWhen:"",ruFix:""},{reg:/^ask\(\) missing 1 required argument: question on line (\d+).?$/i,ru:r=>"Отсутствует аргумент в функции ask",ruWhen:"",ruFix:""}],UnboundLocalError:[{reg:/^local variable (.*) referenced before assignment on line (\d+)$/i,ru:(r,e)=>`Ссылка на локальную переменную ${r} до присваивания ей значения`,ruWhen:"",ruFix:(r,e)=>`Сначала объявите переменную и присвойте ей значение, и только после ссылайтесь на неё. Например, ${r} = 1\ndef f():\n    a = 2\n    print(a)\n\nf()`,errEx:"a = 1\ndef f():\n    print(a)\n    a = 2\nf()"}],ValueError:[{reg:/^(.*) 2nd argument cannot be negative when 3rd argument specified on line (\d+)$/i,ru:(r,e)=>`При наличии третьего аргумента, второй аргумент функции ${r} не может быть отрицательным`,ruWhen:"",ruFix:"Если второй аргумент - отрицательное число, то третий аргумент не будет принят. Если необходимо указать третий аргумент, убедитесь, что первые два аргументы являются целыми положительными числами.",errEx:"pow(0, -1, 1)"},{reg:/^(.*) 3rd argument cannot be 0 on line (\d+)$/i,ru:(r,e)=>`Третий аргумент функции ${r} не может быть равным 0`,ruWhen:"",ruFix:"Третий аргумент - это число, на которое результат возведения в степень делится по модулю. Убедитесь, что оно не равно нулю.",errEx:"pow(0, 0, 0)"},{reg:/^(.*)\(\) arg is an empty sequence on line \d+$/i,ru:(r,e)=>`Аргументом функции ${r} является пустая последовательность`,ruWhen:"",ruFix:(r,e)=>`Убедитесь в передаче функции не пустой последовательности.  Можно также запросить длину объекта перед передачей его в функцию ${r}.`,errEx:"max([])"},{reg:/^(.*) not found on line (\d+)$/i,ru:r=>"Подстрока не найдена",ruWhen:"",ruFix:"",errEx:'"".index("a")'},{reg:/^(.*) step argument must not be zero on line (\d+)$/i,ru:(r,e)=>`Аргумент шага функции ${r} не может быть равным 0`,ruWhen:"",ruFix:"Убедитесь, что используете ненулевое значение шага в формировании последовательности.",errEx:"range(0,0,0)"},{reg:/^(.*)index\(x\)\: x not in (.*) on line (\d+)$/i,ru:r=>"Элемент x отсутствует в списке",ruWhen:"Ошибка возникает при попытке удаления элемента, отсутствующего в списке",ruFix:"Убедитесь, что удаляемый элемент находится в списке. Например, my_list = [1, 3, 2]\nmy_list.remove(1)\nmy_list\n[3, 2]",errEx:"[].remove(1)"},{reg:/^Attempted relative import in non-package on line (\d+)$/i,ru:r=>"Ошибка импорта модуля",ruWhen:"",ruFix:"Убедитесь, что импортируете функцию из конкретной библиотеки. Например, from math import pow.",errEx:"from . import a"},{reg:/^(.*)\(\) arg not in range\(\d+\) on line \d+$/i,ru:(r,e)=>`Превышено максимальное значение аргумента функции ${r}`,ruWhen:"",ruFix:"",errEx:"chr(10000000000)"},{reg:/^complex\(\) arg is a malformed string on line \d+$/i,ru:r=>"Неправильная запись аргумента функции complex() ",ruWhen:"Ошибка возникает при неправильной передаче аргумента в функцию complex()",ruFix:"Передайте в функцию целочисленные аргументы или, если передаёте строчное выражение (например, complex('1-2j')), убедитесь, что вокруг оператора нет пробелов.",errEx:'complex("")'},{reg:/^empty separator on line (\d+)$/i,ru:r=>"",ruWhen:"",ruFix:"",errEx:'"".split("")'},{reg:/^int\(\) base must be >= 2 and <= 36$/i,ru:r=>"Параметр base должен находиться в диапазоне от 2 до 36 или быть равным 0",ruWhen:"",ruFix:"Второй аргумент функции int сообщает, в какой системе счисления находится число, указанное в строке первого аргумента. Доступные системы счисления: от 2- до 36-ричной.",errEx:"int('10', 40)"},{reg:/^invalid literal for (.*) with base (.*): (.*) on line (\d+).?$/i,ru:(r,e,n,i)=>`При помощи функции ${r} в ${e}-чной системе счисления из выражения ${n} нельзя сделать число.`,ruWhen:'Ошибка возникает при попытке превратить плохую строку в число, например int("foo")',ruFix:"В функцию int нужно передавать именно запись числа без лишних букв.",errEx:'int("z")'},{reg:/^need more than (.*) values to unpack on line (\d+).?$/i,ru:(r,e)=>`Требуется больше значений для распаковки, чем ${r}`,ruWhen:"Ошибка возникает при попытке записать в несколько переменных мало значений: a, b, c = [1, 2]",ruFix:"Проверьте число элементов в списке/кортеже/... и число переменных для записи.",errEx:"a, b = [0]"},{reg:/^negative number cannot be raised to a fractional power on line (\d+).?$/i,ru:r=>"Нельзя возводить отрицательное число в нецелую степень",ruWhen:"Ошибка возникает при попытке возвести отрицательное число в степень, например (-2)**0.5",ruFix:"Сделайте либо число положительным, либо степень целой.",errEx:"pow(-2, 0.5)"},{reg:/^negative shift count on line (\d+)$/i,ru:r=>"Операции битового сдвига неприменимы для отрицательных чисел ",ruWhen:"",ruFix:"Используйте в качестве значения сдвига положительное число",errEx:"1<<-1"},{reg:/^slice step cannot be zero on line (\d+)$/i,ru:r=>"Шаг среза не может быть нулевым",ruWhen:"",ruFix:"Убедитесь, что используете ненулевое значение шага среза, так как это противоречит работе срезов. Например, [1,2,3,4,5][1:4:2].",errEx:"[][::0]"},{reg:/^too many values to unpack on line (\d+).?$/i,ru:r=>"Слишком много значений при распаковке",ruWhen:"Ошибка возникает при попытке записать в несколько переменных слишком много значений: a, b = [1, 2, 3]",ruFix:"Проверьте число элементов в списке/кортеже/... и число переменных для записи.",errEx:"a, b = [1, 2, 3]"},{reg:/^Ответ на этот вопрос можно только сравнивать с числами 0, 2, 4, 6, 8 on line (\d+).?$/i,ru:r=>"Ответ на этот вопрос можно только сравнивать с числами 0, 2, 4, 6, 8",ruWhen:"",ruFix:""},{reg:/^Ответ на этот вопрос можно сравнивать только с "Y" и "N" on line (\d+).?$/i,ru:r=>'Ответ на этот вопрос можно сравнивать только с "Y" и "N"',ruWhen:"",ruFix:""},{reg:/^Ответ на этот вопрос можно сравнивать только при помощи == on line (\d+).?$/i,ru:r=>"Ответ на этот вопрос можно сравнивать только при помощи ==",ruWhen:"",ruFix:""},{reg:/^Ответ на этот вопрос можно только сравнивать с числами on line (\d+).?$/i,ru:r=>"Ответ на этот вопрос можно только сравнивать с числами",ruWhen:"",ruFix:""}],ZeroDivisionError:[{reg:/^complex division by zero on line (\d+)$/i,ru:r=>"Деление комплексного числа на 0",ruWhen:"Ошибка возникает при попытке деления на 0",ruFix:"",errEx:"1j/0"},{reg:/^complex division by zero on line (\d+)$/i,ru:r=>"",ruWhen:"",ruFix:"",errEx:"0**1j"},{reg:/^integer division or modulo by zero on line (\d+).?$/i,ru:r=>"Нельзя делить на 0",ruWhen:"Ошибка возникает при попытке деления на 0 или взятия остатка по модулю 0",ruFix:"",errEx:"1/0"}]};